함수의 이해

사용자 정의 함수 개념
호출 -> 동작 -> 되돌아감

- 함수 호출하는 4가지 방법
___________________
호출 	동작 	반환
 O	 O	int sum(int, int)
 O	 X	void sum(int, int)
 X	 O	int sum(void)
 X	 X	void sum(void)


- 인자( Argument ) 는 어떤 함수를 호출시에 전달돼는 값을 말하고
- 매개 형식 변수( Parameter ) 는 그 전달된 인자를 받아들이는 변수다.

- 여기서 포인트는 인자는 값, 매개 형식 변수는 말 그대로 변수라는 점이다.


<포인터로 받는 인자>
- 아래 코드와 같이 어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 그 타입을 가리키는 포인터를 이용해야 한다!
--------------------------------------------
#include <stdio.h>
int swap(int *a, int *b) {
  int temp = *a;
  *a = *b;
  *b = temp;
  return 0;
} 
int main() {
  int i, j;
  i = 3;
  j = 5;
  printf("SWAP 이전 : i : %d, j : %d \n", i, j);
  swap(&i, &j);
  printf("SWAP 이후 : i : %d, j : %d \n", i, j);
  return 0;
}
--------------------------------------------




<함수의 원형> 
- 함수를 main 함수 위에서 정의되는 것이 아니라 main 함수 아래에서 선언될 수 있도록 사용됨
- 다시말하면 컴파일러에게 이 소스코드에 사용되는 함수에 대한 정보를 제공함. (실제 프로그램에는 전혀 반영되지 않는 정보)

ex) int swap(int *a, int *b); <= 이렇게 main 함수 위에 선언 후 함수는 아래에서 작성하는 것을 함수의 원형이라고 함.

- main 함수 위에 함수를 정의하면 상관 없지만 99.9% 의 프로그래머들은 함수를 main 함수의 뒤에 정의하고 원형을 앞에 추가하는 것을 선호함.




<배열을 인자로 받기>
- 배열을 인자로 받아 들이는 함수

-----------------------------------
#include <stdio.h>

int add_number(int *parr);
int main() {
  int arr[3];
  int i;

  /* 사용자로 부터 3 개의 원소를 입력 받는다. */
  for (i = 0; i < 3; i++) {
    scanf("%d", &arr[i]);
  }

  add_number(arr);

  printf("배열의 각 원소 : %d, %d, %d", arr[0], arr[1], arr[2]);

  return 0;
}
int add_number(int *parr) {
  int i;
  for (i = 0; i < 3; i++) {
    parr[i]++;
  }
  return 0;
}
-----------------------------------




<더블 포인터 인자 or 포인터를 가르키는 포인터를 함수 인자로!>

------------------------------------
#include <stdio.h>

int pswap(int **pa, int **pb);
int main() {
  int a, b;
  int *pa, *pb;

  pa = &a;
  pb = &b;

  printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);	 // pa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7520
  printf("pa 의 주소값 : %p \n \n", &pa);		 // pa 의 주소값 : 0x7ffc5ffd7528 
  printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);	 // pb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7524 
  printf("pb 의 주소값 : %p \n", &pb);		 // pb 의 주소값 : 0x7ffc5ffd7530 

  printf(" ------------- 호출 -------------- \n");
  pswap(&pa, &pb);
  printf(" ------------- 호출끝 -------------- \n");

  printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);	 // pa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7524 
  printf("pa 의 주소값 : %p \n \n", &pa);		 // pa 의 주소값 : 0x7ffc5ffd7528 
  printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);	 // pb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7520 
  printf("pb 의 주소값 : %p \n", &pb);		 // pb 의 주소값 : 0x7ffc5ffd7530
  return 0;
}
int pswap(int **ppa, int **ppb) {
  int *temp = *ppa;

  printf("ppa 가 가리키는 변수의 주소값 : %p \n", ppa); // ppa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7528
  printf("ppb 가 가리키는 변수의 주소값 : %p \n", ppb); // ppb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7530 

  *ppa = *ppb;					 // *ppd 는 pb 가 가르키는 변수의 주소며, **ppd 는 *pb 다.
  *ppb = temp;					 // *ppa 는 pa 가 가르키는 변수의 주소다, **ppa 는 *pa 다.

  return 0;
}
------------------------------------




<상수인 인자>
- 상수로 인자를 받아들이는 경우 대부분은 함수를 호출 해도 그 인자의 값이 바뀌지 않는 경우에 자주 사용
- 하지만 함수에서 상수를 사용하여 값을 변경하는 작업은 허용이 되지 않음.




<함수 포인터>
- 함수 포인터를 들으면서 아주 많이 떨림을 받게 되었다.
- 놀랐던 사실은 함수도 메모리 상에 존재하며, 함수를 가르키는 것이 바로 '함수 포인터'이다!

- 배열과 마찬가지로 함수의 이름이 바로 함수의 시작 주소값을 나타낸다.



함수 포인터의 정의

- (함수의 리턴형) (*포인터 이름)(첫번째 인자 타입, 두번째 인자 타입,....)

- 만일 인자가 없다면 그냥 괄호 안을 비워두면 된다. 즉, int (*a)() 와 같이 하면 된다
ex : int (*pmax)(int, int);

- 특정한 함수를 가리킬 때, 그 함수는 반드시 pmax 의 정의와 일치해야 한다.
----------------------
int max(int a, int b);

int main() {
  int a, b;
  int (*pmax)(int, int); 
//int   max  (int a, int b) 와 표현이 같다.

  pmax = max;
// max 함수를 살펴보면 pmax 의 정의와 일치하므로, max 함수의 시작 주소값을 pmax 에 대입 가능
// pmax = &max 와 같은 형식은 틀린 것이다.

printf("max(a,b) : %d \n", max(a, b));
printf("pmax(a,b) : %d \n", pmax(a, b));
// pmax 는 max 함수를 가리키므로 pmax 를 통해 max 함수가 할 수 있는 모든 작업들을 할 수 있다.
// 간단하게 설명하면 pmax 를 max 처럼 이용 가능하다.
}
----------------------


- 그런데 이러한 함수 포인터를 왜 사용할까? 나는 가장 그것이 의문이었다. 

- 찾아보면서 이렇게 사용된다면 꽤 많은 쓰임새가 될 수 있을 것이라고 생각하였다.
- 그것은 바로 매개변수로 받는 것이다!

- 함수 포인터를 인자로 넘겨 매개 변수로 사용한다면 누가 어떤 함수를 필요로 할지 모르지만 어떤 형식으로 함수를 정의해서 매개변수로 전달하게 되어 그 함수를 내부에서는 호출하게 될 수 있다는 것이다.







