구조체 포인터

예제1
----
#include <stdio.h>

struct test {	// struct test이 하나의 형 (타입) 이라는 것을 잊으면 안됨
  int a, b;
};

int main() {
  struct test st;
  struct test *ptr; 	// struct test 형을 가리키는 포인터 ptr을 정의 (주의: ptr 은 절대로 구조체가 아니라는 것)

  ptr = &st; 	// ptr 에 st 의 주소값 대입 | 이제 ptr 은 구조체 st 를 가리키는 포인터가 됨
		// 그런데 그동안 구조체를 배열처럼 사용하였는데 & 연산자를 사용하지 않고 대입해야 한다고 생각할 수 있지만
 		// 구조체는 배열이 아니기 때문에 & 연산자를 사용하여 구조체가 정의된 메모리의 주소값을 얻어옴

  (*ptr).a = 1; 
  (*ptr).b = 2;
  // (*ptr) 이라는 부분이 st 라는 것과 동일하다
  // ptr 이 st 를 가리키고 있기 때문에 (*ptr).a = 1 은 st.a = 1 과 완전히 100% 동일한 문장

  // 괄호를 쳐 주어야 하는 이유는 컴파일 오류가 발생하기 때문인데 연산자 우선순위로 인한 오류이다.
  // 연산자 우선 순위 표 를 보면 가장 첫번째가 "() [] -> ." 이다. 두번째는 "! ~ ++ -- *(포인터) & 등" 있다.
  // . 은 구조체의 멤버를 지칭할 때 . 을 의미한다. (ex: (*ptr).a)
  // 여기서 주목해야 할 점은 . 이 * 보다 우선순위가 높다는 것이다. 

  // 괄호를 치지 않고 *ptr.a 를 사용하면 ptr.a 를 먼저 실행한 후 *을 하여 *(ptr.a) 이런 형태에 2가 대입됨
  // ptr은 단순히 포인터에 불과하며, ptr은 절대 구조체가 아니다. 
  // 그런데 구조체가 아닌 것의 있지도 않는 a라는 멤버에 접근은 당연히 되지 않으며 그렇기 때문에 컴파일 시 오류가 발생된다. 

  // 결과적으로 구조체 포인터를 사용해서 멤버에 접근하려면 (*ptr).a 와 같이 언제나 괄호로 감싸 주어야 한다. 
  // 하지만 똑똑한 C 프로그래머들은 이 문제를 해결하기 위해 다음과 같은 아름다운 기호를 등장함.

  // 솔직히 상기 설명은 완벽하게 이해하지 않아도 다음 연산자를 이해하면 될 것이다.

  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);

  return 0;
}



















