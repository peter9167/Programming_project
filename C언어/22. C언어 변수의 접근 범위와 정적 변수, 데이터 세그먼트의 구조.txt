<전역 변수>

- 어떠한 지역에도 속해있지 않은 변수를 전역 변수(global variable)
- 지역 변수의 경우 함수가 종료 될 때 파괴되는데 전역 변수는 프로그램이 시작할 때 생성 후 프로그램이 종료 될 때 파괴
- 전역 변수는 지역 변수와는 달리 메모리의 데이터 영역(Data segment)에 할당 됩니다.

- 모든 전역 변수들은 정의 시 자동으로 0 으로 초기화 된다

- 전역 변수는 모든 함수에서 접근할 수 있기 때문에 전역 변수를 사용할 때에는 매우 주의
- 전역 변수를 수십개 선언하면 필연적으로 문제 발생


<변수의 생존 기간>

- 일반적으로 정의된 변수들은 자신이 정의된 지역을 빠져나갈 때 파괴
  쉽게 말하면 자신이 정의된 위치를 포함하고 있는 {} 를 벗어날 때 해당 변수가 사라지게 된다는 뜻
--------------------
#include <stdio.h>

int* function() {
  int a = 2;
  return &a;
}

int main() {
  int* pa = function();
  printf("%d \n", *pa);
}
--------------------
- 위 코드 컴파일 시 오류 발생. 이유는 아래 자세히 작성

- a 라는 변수는 지역 변수이기 때문에 a 가 정의된 지역인 function 을 빠져나가면 a 는 소멸되며, a를 사용할 수 없다.
- a 의 주소값을 리턴해서 function 외부에서 a 를 사용하면 pa 는 파괴된 a 변수를 가리키고 있기 때문에 문제 발생

- 지역을 빠져나가도 파괴되지 않는 변수 : 정적 변수 (static variable) 이라 한다.

<정적 변수>

- 정적 변수를 선언하기 위해서는 일반적인 변수 선언 앞에 static 만 붙여주면 된다. 
ex) static int a = 2;

- 그리고 해당 변수는 자신이 선언된 범위를 벗어나더라도 절대로 파괴되지 않는다.

--------------------
#include <stdio.h>

int* function() {
  static int a = 2;
  return &a;
}

int main() {
  int* pa = function();
  printf("%d \n", *pa);
}
--------------------

- 따라서 a 가 정의된 지역 밖에서 접근하더라도 a 는 소멸되지 않았기 때문에 2 라는 값이 잘 출력되는 것이다.

- 그렇다면 한 가지 궁금한 점은 function 을 여러번 호출하면 a 가 여러번 2 로 초기화 되냐고 물을 수 있다. 
  하지만 a 는 딱 한 번만 초기화 된다. 다시 말해 static int a = 2 라는 문장은 딱 한 번 실행 되며, 
  더 놀라운 점은 function 을 실행하지 않더라도 a 라는 정적 변수는 이미 정의되어 있는 상태이다.

- 따라서 이와 같은 정적 변수를 사용하면 아래 코드처럼 해당 함수가 몇 번 호출되었는지도 쉽게 추적할 수 있다. 

/* 정적 변수의 활용 */
#include <stdio.h>

int function() {
  static int how_many_called = 0;

  how_many_called++;
  printf("function called : %d \n", how_many_called);

  return 0;
}
int function2() {
  static int how_many_called = 0;

  how_many_called++;
  printf("function 2 called : %d \n", how_many_called);

  return 0;
}
int main() {
  function();
  function2();
  function();
  function2();
  function2();
  function2();
  function();
  function();
  function2();
  return 0;
}

참고로 정적 변수의 경우 전역 변수처럼 데이터 영역에 저장되고 프로그램이 종료될 때 파괴된다. 
또한 전역 변수처럼 정적 변수도 정의시 특별한 값을 지정해 주지 않는 한 0 으로 자동 초기화 된다.



<데이터 세그먼트의 구조>

- 프로그램을 만들기 위해서는 C언어나 기타 언어를 통해 소스를 작성한 후, 소스를 컴파일하게 된다.
- 컴파일된 프로그램은 데이타의 종류에 따라 메모리(RAM)의 다른 곳에 위치하게 되는데 
  각각의 위치를 메모리 세그먼트라 하며, 아래와 같이 다섯개의 종류로 구분되어진다.

  스택(Stack) 지역변수가 위치
--------------
      ↓
      ↑
--------------
   힙(Heap)
--------------
 ﻿데이터 영역
(전역 변수와
 정적 변수가 위치)
--------------
Read-Only Data
(상수와 리터럴들이
 여기 위치한다)
--------------
   코드 영역


- 읽기 전용(Read-Only) Data 부분은 이 부분에 저장되는 데이터들은 절대로 변경될 수 없다. 
  궁극적으로 보호 받는 부분
- 데이터 영역은 전역 변수와 정적변수가 저장됨
- 힙(Heap) 영역은 프로그래머가 직접 할당한 메모리가 저장되는 영역으로, malloc() 함수를 사용해 메모리 할당 가능
  사용자의 쓰임에 따르 그 크기가 달라지며, 메모리의 낮은 주소에서 높은 주소 방향으로 증가한다.
- 스택(Stack) 영역은 지역 변수가 저장된다. 
  스택의 특징으로는 지역 변수가 늘어나면 크기가 아래로 증가하다가 
  지역변수가 파괴되면 다시 스택의 크기는 위로 줄어들게 됩니다.
  즉, 스택이 늘어나는 방향은 메모리 주소가 낮아지는 방향(아래 방향) 이다.



﻿
메모리의 배치 모습 예제1
----
/* 메모리의 배치 모습 */

#include <stdio.h>

int global = 3;

int main() {
  int i;
  char *str = "Hello, Baby";
  char arr[20] = "WHATTHEHECK";

  printf("global : %p \n", &global);	// 0x403010
  printf("i : %p \n", &i);		// 0x62FE14
  printf("str : %p \n", str); 		// 0x404000
  printf("arr : %p \n", arr);		// 0x62FE00
}

- 가장 먼저 읽기 전용(Read Only) 데이터인 str 을 보면 str 에는 “Hello, Baby” 라는 리터럴의 주소값이 대입. 
  따라서, str 의 값을 출력했다면 Read Only 데이터의 위치를 대략 알 수 있다. 
  여기서는 0x404000 로 나온다. 예상 대로 출력된 주소값들 중 가장 작게 나온다. 
  왜냐하면 Read Only data 는 데이터 세그먼트 맨 아래에 위치해 있기 때문이다.

- 두 번째로 전역 변수인 global 의 주소값을 살펴보면 str 보다는 살짝 크지만 
  여기서는 0x403010 로 나오며, 다른 것들 보다는 많이 작다는 것을 알 수 있다. 
  이는 global 이 전역 변수로 데이터 영역에 위치해 있기 때문이다. 

- 세 번째로 i 를 보자면 지역 변수 이기 때문에 stack 에 존재하고 있다. 
  stack 의 경우 지역 변수를 추가할 수록 메모리 주소가 작아지는 방향으로 
  추가가 되므로 i 보다 나중에 추가 된 arr 의 주소값이 더 작다.

- 이들이 데이터 세그먼트에 배치된 모습을 아래 나타냄

    int i	0x62FE14 : i
--------------
       arr[19]
--------------
      .
      .
--------------
      H arr[1]
--------------
      W arr[0]	0x62FE00 : arr
--------------
      .
      .
--------------
   HEAP 영역
--------------
  global = 3	0x403010 : global
--------------
      .
      .
--------------
"Hello, Baby"	0x404000 : str
--------------
    코드 영역