상수 포인터 (const int*, int* const)

const 라는 키워드는 이 데이터의 값은 절대로 바뀌면 안된다는 것을 나타냄

const int a 변수는 int 형 변수 a 인데 값이 절대로 바뀌면 안되는 변수
----------------------------------------------------------
const int* pa 변수는 형 변수 값을 바꾸면 안된다는 것이 아님
      int 형 변수를 가르키는 주소값을 절대로 바꾸지 말라는 의미

    const int* pa = &a
      곧, pa 변수를 위와 같이 선언한다면 pa = &b 같이 주소값 변경은 되지 않지만 *pa = 3; 과 같이 데이터 값을 변경해도 상관없음

##################

포인터의 덧셈

------------------
 int a;
 int* pa;1
 pa = &a;
 printf("%p \n", pa);		결과 : 0x7ffd6a32fc4c
 printf("%p \n", pa + 1);	결과 : 0x7ffd6a32fc50
------------------
pa + 1 을 하면 0x7ffd6a32fc4c 에 1 이 더해진 0x7ffd6a32fc4d 가 아니라, 4 가 더해진 0x7ffd6a32fc50 이 출력

4가 추가 된 이유는 1을 더한다는 의미는 Data Type에 크기를 더한다는 의미다.
만약 char(1byte) 에서 1을 더하면 1이 더해지고, double(8byte) 은 1을 더하면 8이 더해진다. 

그런데 왜 포인터가 가르키는 DataType의 크기만큼 더할까?
그 이유는 배열을 보면 알 수 있는데 배열은 DataType에 크기만큼에 저장공간을 만들며, 각 공간에 데이터를 저장한다. 
포인터를 이용해서 배열의 각 원소를 가르킬 수 있다. 정수를 더하고 뺌으로 * 를 이용하여 원소들과 똑같은 역할이 가능하다는 것이다. 

------------------
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int* parr;
for (int i = 0; i < 10; i++) {
 printf("%p ", i, &arr[i++]);	아래 코드와 같은 기능을 갖는다.
 printf("%p ", i, (parr + i));	위 코드와 같은 기능을 갖는다. 
}
------------------
