포인터 배열 : 배열을 가르키는 포인터

2차원 배열의 [] 연산자(첨자 연산자)

- 2 차원 배열은 메모리에 선형으로 존재, 2차원이라고 생각하는 것

-----------------------------------------
int arr[2][3];

printf("arr[0] : %p \n", arr[0]);	  결과: arr[0] : 0x7ffda354e530
printf("&arr[0][0] : %p \n", &arr[0][0]); 결과: &arr[0][0] : 0x7ffda354e530

printf("arr[1] : %p \n", arr[1]);	  결과: arr[1] : 0x7ffda354e53c
printf("&arr[1][0] : %p \n", &arr[1][0]); 결과: arr[1] : 0x7ffda354e53c
-----------------------------------------

- arr 이 arr[0] 을 가르키는 포인터로 암묵적 타입 변환인 것처럼
- arr[0] 은 arr[0][0] 을 가리키는 포인터로 암묵적으로 타입 변환

- 1 차원 배열 int arr[] 에서 arr 과 &arr[0] 는 그 자체로는 완전히 다른 것이였던 것처럼 
  2 차원 배열 int arr[][] 에서 arr[0] 과 &arr[0][0] 와 다릅니다. 
- 다만 암묵적으로 타입 변환 시에 같은 것으로 변할 뿐입니다.


sizeof 를 사용하였을 경우 2 차원 배열의 열의 개수를 계산 (아래 코드 참고)
-----------------------------------------
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
printf("전체 크기 : %d \n", sizeof(arr));					결과: 전체 크기 : 24
printf("총 열의 개수 : %d \n", sizeof(arr[0]) / sizeof(arr[0][0]));	결과: 총 열의 개수 : 3
printf("총 행의 개수 : %d \n", sizeof(arr) / sizeof(arr[0]));		결과: 총 행의 개수 : 2
-----------------------------------------

- 2차원 배열의 이름을 포인터에 전달하기 위해서는 해당 포인터의 타입은?
- arr[0] 는 int * 가 보관할 수 있으니까, arr 은 int ** 이 보관 가능한가? 답은 아니다. 



<포인터의 형(type)을 결정짓는 두 가지 요소>

- 배열의 이름이 왜 int** 형이 될 수 없는 이유는?
- 만일 int** 형이 될 수 있다면 맨 위에서 했던 것 처럼 int** 포인터가 배열의 이름을 가리킨다면 배열의 원소에 자유롭게 접근해야 한다.
- 하지만 2차원 배열을 가르키는 포인터를 통해서 원소들을 정확히 접근하기 위해서는 가르키는 
 1. 원소의 크기(DataType[int=4byte])와 
 2. 열의 값을 알아야 한다. 

- 위 두 정보가 포인터의 타입에 명시되어 있어야지 컴파일러가 원소를 올바르게 접근 가능
- 그렇기 때문에 int ** 포인터 타입으로는 원소를 올바르게 접근하거나 보관할 수 없다.  


- 2 차원 배열을 가리키는 포인터는 배열의 크기에 관한 정보가 포함되어야 하기 때문에 아래와 같이 작성함

int (*parr)[3]; // (*(포인터 이름))[2 차원 배열의 열 개수];

이렇게 포인터를 정의하였을 때 앞서 이야기한 포인터의 조건을 잘 만족하는지 보도록 합시다. 
- (배열의 형) 을 통해서 원소의 크기에 대한 정보를 알 수 있으며, 가리키는 것에 대한 정보 전달 가능 (조건 1 만족)
- [2 차원 배열의 열 개수] 를 통해서 열의 값을 전달 가능 (조건 2 만족)

-----------------------------------------
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
int **parr;

parr = arr;

printf("parr[1][1] : %d \n", parr[1][1]);  // 버그!
-----------------------------------------

parr[1][1] 은 *(*(parr + 1) + 1) 과 동일한 문장이다. parr + 1 을 하면
parr 은 int* 를 가리키는 포인터 이고, int* 의 크기는 8 바이트 이기 때문에 parr + 1 을 하면 실제 주소값이 8 증가하게 됨.

따라서 parr + 1 은 arr 배열의 세 번째 원소의 주소값을 가지게 됩니다 (왜냐면 int 는 4 바이트 니까). 
따라서 *(parr + 1) 은 3 이 될 것입니다.

그 다음에 *(parr + 1) + 1 을 하면 몇이 증가할까요? 현재 (parr + 1) 의 타입은 int * 이다. 
따라서 int 의 크기 만큼인 4 가 늘어나게 됩니다. 결국 *(parr + 1) + 1 은 7 이다.

결국 *(*(parr + 1) + 1) 은 마치 주소값 7 에 있는 값을 읽어라! 하는 말과 동일하다. 
그리고 해당 위치는 프로그램이 읽을 수 없기에 오류가 발생하게 되는 것이다.








