<1차원 배열 가르키기>

int arr[5]={1, 2, 3, 4, 5};

arr 라는 변수는 arr[0]의 주소값을 가짐. 곧 배열의 시작 주소를 가짐.

arr 은 배열의 첫 번째 원소를 가리키는 포인터로 변환되고, 그 원소의 타입이 int 이므로, 포인터의 타입은 int* 으로 대입 (아래 내용 참고)

int* parr = arr;	: 아래 코드와 같음
int* parr = &arr[0] 	: 위 코드와 같음



<포인터의 포인터 or 이중 포인터>

int **p;

위는 int 를 가리키는 '포인터를 가리키는 포인터' 이다. 

--------------------------------------
int *numPtr1;     	// 단일 포인터 선언
int **numPtr2;    	// 이중 포인터 선언
int num1 = 10;

numPtr1 = &num1;   	// num1의 메모리 주소 저장 
numPtr2 = &numPtr1;
--------------------------------------

포인터도 실제로는 변수이기 때문에 메모리 주소를 구할 수 있다. 
하지만 포인터의 메모리 주소는 일반 포인터에 저장할 수 없고, int **numPtr2;처럼 이중 포인터에 저장해야 한다.

이중 포인터 numPtr2를 끝까지 따라가서 실제 값을 가져오려면 **numPtr2처럼 변수 앞에 역참조 연산자를 두 번 사용하면 됨

역참조 연산자를 두 번 사용 이론
      numPtr2      →      numPtr1      →      num1
numPtr1의 메모리 주소    num1의 메모리 주소          10

포인터를 선언할 때 *의 개수에 따라서 삼중 포인터, 사중 포인터 그 이상도 만들 수 있다. 
마찬가지로 역참조를 할 때도 *를 세 번, 네 번 또는 그 이상 사용할 수 있다.



<배열 이름의 주소값>

배열 이름에 sizeof 연산자와 주소값 연산자를 사용할 때 빼고는 전부다 포인터로 암묵적 변환이 이루어짐

--------------------------------------
int arr[3] = {1, 2, 3};
int (*parr)[3] = &arr;

printf("arr[1] : %d \n", arr[1]);		결과 : arr[1] : 2 
printf("parr[1] : %d \n", (*parr)[1]);	결과 : parr[1] : 2 
--------------------------------------

- int (*parr)[3] = &arr; 에서 &arr은 무슨 의미일까? 
- arr 은 int * 로 암묵적 변환이 이뤄짐
- arr 이 크기가 3인 배열이기 때문에 &arr 을 보관할 포인터는 크기가 3인 배열을 가리키는 포인터다.

- C언어 문법상 정의는 아래와 같으며, 참고로 parr 을 정의할 때 *parr 을 꼭 () 로 감싸야만 하는데 int *parr[3] 와 같이 되어서
C 컴파일러가 int * 원소 3개를 가지는 배열을 정의하는 것으로 오해하게 되어 사용하면 () 제외하고 사용하면 안됨

printf("parr[1] : %d \n", (*parr)[1]);

parr 은 크기가 3 인 배열을 가리키는 포인터 이기 때문에 배열을 직접 나타내기 위해서는 * 연산자를 통해 원래의 arr 을 참조한다.
따라서 (*parr)[1] 과 arr[1] 은 같은 문장 이다. 

