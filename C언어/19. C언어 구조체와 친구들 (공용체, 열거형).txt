공용체

- 공용체는 구조체와 정의 방법이 같지만 멤버를 저장하는 방식이 다름
- 구조체는 멤버들이 각각 공간을 차지
- 공용체는 모든 멤버가 공간을 공유

- 공용체의 각 멤버들의메모리 시작 주소는 모두 동일하다. 
- 가장 큰 자료형의 공간을 공유함
- 하지만 공용체는 실무에서 사용되는 빈도가 적기 때문에 완벽하게 이해할 필요없다.

<공용체 문법>
union 공용체이름
{
  자료형 멤버이름;
};
union 공용체이름 변수이름;

- 공용체는 보통 main 함수 바깥에 정의한다.
------------------------------
union Box {    // 공용체 정의
    short candy;     // 2바이트
    float snack;     // 4바이트
    char doll[8];    // 8바이트
};
------------------------------

- 함수 안에서 공용체를 정의하면 해당 함수 안에서만 공용체를 사용할 수 있다.
- 정의한 공용체를 사용하려면 공용체 변수를 선언해야 한다. 
- 공용체 이름 앞에 반드시 union 키워드를 붙여줍니다.


- 다음은 Box 공용체 타입의 변수 b1을 선언한다는 뜻이다. 
------------------------------
union Box b1;    // 공용체 변수 선언
printf("%d\n", sizeof(b1));  // 8 : 공용체의 전체 크기는 가장 큰 자료형의 크기 출력
------------------------------


- 일반 변수로 선언한 공용체의 멤버에 접근할 때는 . (점)을 사용
------------------------------
strcpy(b1.doll, "bear");     // doll에 문자열 bear 복사

printf("%d\n", b1.candy);    // 25954
printf("%f\n", b1.snack);    // 4464428256607938511036928229376.000000
printf("%s\n", b1.doll);     // bear
------------------------------
- printf로 b1.candy, b1.snack, b1.doll의 값을 출력해보면 
  b1.doll은 "bear"가 정상적으로 출력되지만 b1.candy, b1.snack은 값이 엉망
- 구조체와는 달리 공용체는 멤버 중에서 가장 큰 자료형의 공간을 공유
- 따라서 어느 한 멤버에 값을 저장하면 나머지 멤버의 값은 사용할 수 없는 상태가 된다.


- 공용체의 멤버는 한 번에 하나씩 쓰면 값을 정상적으로 사용할 수 있습니다.
------------------------------
b1.candy = 10;
printf("%d\n", b1.candy);    // 10: 사용(출력)

b1.snack = 60000.0f;
printf("%f\n", b1.snack);    // 60000.00000000: 사용(출력)

strcpy(b1.doll, "bear");
printf("%s\n", b1.doll);     // bear: 사용(출력)
------------------------------
- 만약 b1.candy, b1.snack, b1.doll을 구조체로 만들었다면 구조체의 전체 크기는 2 + 4 + 8 = 14바이트이다. 
- 공용체로 멤버를 한 번에 하나씩만 쓰는 상황이라면 크기는 8바이트이므로 6바이트 이득

- 실무에서는 공용체에 값을 저장할 때 어떤 멤버를 사용할 것인지 미리 정해놓고, 꺼낼 때도 정해놓은 멤버에서 값을 꺼내는 식으로 사용
- 즉, 선물상자 바깥에 어떤 물건이 들어있는지 적어놓고 사용하는 식

- 정리하자면 공용체는 여러 멤버에 동시에 접근하지 않는 경우 같은 메모리 레이아웃에 멤버를 모아둘 때 사용
- 히 공용체는 임베디드 시스템이나 커널 모드 디바이스 드라이버 등에서 주로 사용하며 보통은 거의 쓰지 않는다.





-------------
union A
{
  int i;
  char j;
};
-------------

- union A 의 경우 j 의 값을 변경함으로써 i 의 값을 변경할 수 있고 
  마찬가지로 i 의 값을 변경함으로써 j 의 값을 변경
- 아래 예제 코드를 통해 동작 원리 확인

-------------------------
/* 공용체 */
#include <stdio.h>
union A {
  int i;
  char j;
};
int main() {
  union A a;
  a.i = 0x12345678;
  printf("%x", a.j); // 78 출력 
  return 0;
}
-------------------------

- a 의 j 멤버 값을 전혀 설정해 주지 않았음에도 불구하고 i 에 0x12345678 을 대입하자 j 의 값이 78 이 출력됨



<바이트 저장 순서(byte order)>
1. 빅 엔디안 (Big Endian)

- 빅 엔디안 방식은 낮은 주소에 데이터의 높은 바이트(MSB)부터 저장하는 방식이다.
- 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기가 쉽다는 장점을 가지고 있다.

- 다음과 같이 저장할 32비트 크기의 정수가 있다고 가정하면
ex) 0x12345678

- 정수는 각각 다음과 같이 1바이트값 4개로 구성된다. 
ex) 0x12, 0x34, 0x56, 0x78

- 4개의 1바이트 값을 빅 엔디안 방식으로 저장하면 아래와 같이 저장된다.

	메모리
----
0x12 ← 낮은 주소 | MSB
----
0x34
----
0x56
----
0x78 ← 높은 주소 | LSB


2. 리틀 엔디안 (Little Endian)

- 리틀 엔디안 방식은 낮은 주소에 데이터의 낮은 바이트(LSB)부터 저장하는 방식이다.
- 숫자를 사용하는 선형 방식과는 반대로 거꾸로 읽어야한다. 
- 대부분의 인텔 CPU 계열에서는 이 방식으로 데이터를 저장한다.

- 앞서 예를 든 정수 "0x12345678"를 리틀 엔디안 방식으로 저장하면 아래와 같이 저장된다.

메모리
----
0x78 ← 낮은 주소 | LSB
----
0x56
----
0x34
----
0x12 ← 높은 주소 | MSB


- 공용체에 관한 설명은 여기서 끝
- 아마도 공용체를 접할 가능성이 100 번 코딩 하다 보면 1 번 나올까 말까 한데 
  이를 자세히 짚고 넘어가는 것은 큰 의미가 없다고 생각한다.
- 사실 공용체에 대해 배운 것 보다는 엔디안에 대해 배운 것이 훨씬 중요하기 때문에 
  혹여라도 엔디안에 대해 잊는 일은 없길 바란다.



"빅 엔디안, 리틀 엔디안"을 다시 한 번 정리하면 

값을 저장할 수 있는 바이트가 4개 있다고 한다. (▀ ▀ ▀ ▀)

1. 가장 큰 값이 첫번째 바이트 메모리에 할당이 되고, 가장 작은 값이 마지막 바이트 메모리에 할당되는 방식
2. 가장 큰 값이 마지막 바이트 메모리에 할당이 되고, 가장 작은 값이 첫번째 바이트 메모리에 할당되는 방식

- 이러한 메모리 저장 방식을 바이트 저장 순서(byte order) 라고 한다. 
- 1번 방식을 빅 엔디안 (Big-Endian) 방식이라고 하고, 
  2번 방식을 리틀 엔디안 (Little-Endian) 방식이라고 한다.





<열거형>



